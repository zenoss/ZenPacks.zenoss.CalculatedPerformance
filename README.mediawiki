<p>Calculated Performance v2.0</p>
<h1 id="overview">Overview</h1>
<p>The Calculated Performance ZenPack provides a few capabilities for creating <em>derived datapoints</em>. A derived datapoint's value is determined based on the values of other datapoints or attributes, as opposed to being collected directly from a target device or component. There are two different types of derived datapoint provided: Calculated Performance and Datapoint Aggregator. Both of these types are collected within the zenpython daemon provided by PythonCollector, so no new daemons are required.</p>
<p>Calculated Performance datapoints are functionally the same as in v1.x. By configuring a Python expression, you can combine any datapoints or model attributes from the target device or component. The capabilities of the Python expression have been expanded in v2.0.</p>
<div class="figure">
<img src="calculation_basic.png" alt="Simple calculated datapoint example" /><p class="caption">Simple calculated datapoint example</p>
</div>
<p>Datapoint Aggregator datapoints are a new capability in v2.0. They perform a point-in-time aggregation of any other datapoint on a set of target elements. The target elements in question can be any elements in the Zenoss system that have datapoints associated with them. This is not limited by type, Device Class, or containing device, though it is limited to elements collected on the same physical collector as the aggregating element. An aggregation can be any n-ary commutative mathematical operation, such as sum, maximum, or standard deviation. Most aggregations give results in the same units as the input.</p>
<div class="figure">
<img src="aggregation_basic_diagram.png" alt="Simple aggregating datapoint example" /><p class="caption">Simple aggregating datapoint example</p>
</div>
<h2 id="caveats">Caveats</h2>
<p>All derived datapoints rely on reading previously collected target datapoints from the performance data store. As such, the calculation of the derived value will be delayed by as much as an entire collection cycle. In general, derived datapoints should be considered to incur a 1-cycle delay for each aggregation or calculation step. In practice, we can often compute an entire tree of aggregation and calculation steps in the same collection cycle. See: <a href="#bookmark=id.ausvy7fklq5l">Best Practices for Derived Datapoints: Using Topological Sort</a>.</p>
<p>Because performance data is stored locally on the collector, only devices and components on the same collector can be aggregated.</p>
<p>Derived datapoints are only based on the most recent available data from target datapoints. This is limited to data up to 5*cycleTime seconds in the past. If a target datapoint does not exist on the target element, or has not been collected in the recent past, that element will be excluded from the calculation. This may mean that fewer datapoints than desired are used in the calculation (for aggregate datapoints), or that the overall result cannot be calculated at all. An event will be sent when this occurs.</p>
<h1 id="calculated-performance">Calculated Performance</h1>
<p>A Calculated Performance datasource contains a Python expression whose result will be stored as the value of the single datapoint. The expression can reference any other datapoint or model attribute on the device or component. For example, the expression <code>(hw.totalMemory â€“ memAvailReal) / hw.totalMemory</code> uses the totalMemory attribute modeled from the device and the datapoint memAvailReal to calculate a percentage used. Dotted-name model attributes can reference functions or relationships as long as they take no arguments. Datapoints can be referenced using only the datapoint name, or as datasource_datapoint. If there are model attributes and datapoints that have a name conflict, the datapoint's value will be used. To disambiguate, you can use <code>here.attribute</code> to specify a model attribute, and the <code>datasource_datapoint</code> name to specify a datapoint.</p>
<p>In v2.0, the capabilities of the expression have been expanded. Any <code>eval</code>-able Python code can be used, including control structures and any built-in functions, as long as it returns a single numeric value. This means that any Python keyword (anything in keyword.kwlist) and any Python builtin (See: builtins) are reserved words that cannot be used as attribute or datapoint names. If a model attribute or datapoint has a name conflict with a reserved identifier, the <code>here.attribute</code> or <code>datasource_datapoint</code> syntax will resolve the issue.</p>
<p>In addition, the expression has access to a few provided utility functions:</p>
<ul>
<li><p><code>avg(dpList)</code>: Computes the average value of a list of items, excluding any None values.</p></li>
<li><p><code>pct(numeratorList, denominatorList)</code>: Computes a percentage of sums of the numerator list and the denominator list. None values are assumed to be zero, and if the denominator is zero the returned value is zero.</p></li>
</ul>
<h1 id="datapoint-aggregator">Datapoint Aggregator</h1>
<h2 id="configuring-a-datapoint-aggregator-datasource-and-datapoints">Configuring a 'Datapoint Aggregator' Datasource and Datapoints</h2>
<p>A Datapoint Aggregator datasource is a datasource like any other: it resides in a template, which will be bound to a device or component that we will attempt to collect against. The aggregating datasource has two important pieces of configuration: the target elements to get data from, and the target datapoint on those elements.</p>
<p>The elements to collect from are controlled by the configured Target Method name. This can be any method or relationship present on the element type to which the template will be bound, and must require no arguments. This method must return an iterable of all elements against which we will collect. For example, for an aggregate datasource on a device, we could collect from all of its components by setting this field to <code>getMonitoredComponents</code> or from all of its interfaces by using <code>os.interfaces</code>. By default, the method is <code>getElements</code>, which is expected to be used on a custom ElementPool component. See: <a href="#bookmark=id.34wzelyfww68">Implementing a Custom ElementPool Component</a>.</p>
<p>The datapoint to collect from each element is specified by the Datasource, Datapoint, and RRA fields. As expected, this will collect the value from datasource_datapoint:RRA on each target element before aggregating the set of values.</p>
<p>A datapoint on a Datapoint Aggregator type datasource provides the configuration of the aggregation operation to perform on the set of collected values. Multiple such datapoints can be configured on a single datasource to perform several aggregations on the same set of data. The 'Operation' field must be one of the available operations provided by the ZenPack. Some operations may take additional arguments, which should be a string of comma-separated values in the 'Arguments' field.</p>
<h2 id="available-aggregation-operations">Available Aggregation Operations</h2>
<p>The following aggregation operations are available (aliases included). Operations that result in different units than those submitted are noted.</p>
<ul>
<li><p><code>count</code>: The number of elements collected. Not unit-consistent.</p></li>
<li><p><code>sum</code>: The sum of all elements collected.</p></li>
<li><p><code>max</code>: The maximum of all elements collected.</p></li>
<li><p><code>min</code>: The minimum of all elements collected.</p></li>
<li><p><code>amean</code> (<code>avg</code>): The <a href="http://en.wikipedia.org/wiki/Arithmetic_mean">arithmetic mean or average</a> of all elements collected.</p></li>
<li><p><code>median</code>: The <a href="http://en.wikipedia.org/wiki/Median">median</a> of all elements collected.</p></li>
<li><p><code>stddev</code> (<code>std</code>): The <a href="http://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> of all elements collected.</p></li>
<li><p><code>var</code>: The <a href="http://en.wikipedia.org/wiki/Variance">variance</a> of all elements collected. Not unit-consistent.</p></li>
<li><p><code>mad</code>: The <a href="http://en.wikipedia.org/wiki/Median_absolute_deviation">median absolute deviation</a> of all elements collected.</p></li>
<li><p><code>percentile</code>: Takes an additional argument <code>n</code> (0-100). Returns the <a href="http://en.wikipedia.org/wiki/Percentile">nth percentile</a> value from the set of target datapoints.</p></li>
</ul>
<h2 id="thresholding-on-aggregate-datapoints-additional-event-detail">Thresholding on Aggregate Datapoints: Additional Event Detail</h2>
<p>When a MinMax threshold is violated on an aggregate datapoint, an additional event detail is added to the generated event. The <code>violator</code> detail of the event will contain a set of (uid, value) tuples for each target element whose value is above the threshold. For example, if the median operation is applied to [3,3,5,9,11] and has a maximum threshold of 4, the elements corresponding to the 5, 9, and 11 values would appear in the <code>violator</code> detail.</p>
<p>The value given in the <code>violator</code> tuple will correspond to the aggregate operation requested: the <code>std</code> and <code>mad</code> operations will provide each element's deviation as its corresponding value, and the <code>var</code> operation will provide the square of each element's deviation. All other aggregations will use the value of the target datapoint as collected.</p>
<h2 id="best-practices-for-derived-datapoints-using-topological-sort">Best Practices for Derived Datapoints: Using Topological Sort</h2>
<p>As mentioned above, both Calculated Performance and Datapoint Aggregator datasources incur a 1-collection cycle delay when collecting. This problem compounds when both are in play. Each time you calculate or aggregate a datapoint, a 1-cycle delay is added. In this example, some aggregations are performed, then a calculation, then a final aggregation. Each step incurs a 1-cycle delay, resulting in data that is 4 cycles old by the time the final aggregation is stored.</p>
<div class="figure">
<img src="aggregation_delay_diagram.png" alt="Cycles of Delay for Aggregation and Calculation" /><p class="caption">Cycles of Delay for Aggregation and Calculation</p>
</div>
<p>However, not all compound datapoints necessarily incur a delay. If the derived datapoints for the Final Aggregator, Calculated Point, Super Aggregator, and both Aggregating Entities are set to the same cycle time, and all of these datasources are within a single device's context (i.e., the device itself or a component of that device), we will perform a <a href="http://en.wikipedia.org/wiki/Topological_sorting">topological sort</a> on the datapoint dependency graph to attempt to collect them so that all three values are available within one collection cycle. This sorting requires that there be no cyclic dependencies between datapoints.</p>
<div class="figure">
<img src="aggregation_delay_mitigated.png" alt="Mitigated Cycles of Delay for Aggregation and Calculation" /><p class="caption">Mitigated Cycles of Delay for Aggregation and Calculation</p>
</div>
<h1 id="implementing-a-custom-elementpool-component">Implementing a Custom ElementPool Component</h1>
<p>There are many scenarios for using an aggregate datapoint where it makes no sense to put the aggregate datapoint on an existing device or component. For example, an aggregate datapoint may want to calculate across disparate devices and components. For this situation, we provide a generic <code>ElementPool</code> component. The base <code>ElementPool</code> stores its members as a list of UUIDs of device/components to target, and implements the <code>getElements()</code> method that will return the appropriate list.</p>
<p>To implement your own specific type of component with pool functionality, inherit from <code>ElementPool</code> and implement the <code>getMembers()</code> method as desired. Your component need not use the internal member list, or may store other values in the list, as long as the <code>getMembers()</code> method returns the correct items. Then, configure your aggregate datapoints to target the <code>getMembers</code> function (this is the default).</p>
<p>You must create these components at modeling time like any other component. Then the configured datapoints will be collected.</p>
<pre><code>class RandomContentsElementPool(ElementPool):
    portal_type = meta_type = &#39;RandomContentsElementPool&#39;

    def getElements(self):
        return [x for x in self.device().getMonitoredComponents() if random.random() &gt; 0.314159]</code></pre>
